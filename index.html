<!--https://github.com/mrpandey/d3graphTheory/tree/master/ch/vertices-and-edges-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <style>
      svg {
          cursor: crosshair;
          display: block;
          margin: auto;
      }

      .edge {
          stroke: #888;
          stroke-width: 2px;
          stroke-linecap: round;
          stroke-linejoin: round;
          cursor: default;
      }

      .edge:hover,
      .dragLine {
          stroke: #333;
          stroke-width: 3px;
      }

      .vertex {
          cursor: pointer;
      }

      .vertex:hover {
          stroke: #333;
          opacity: 0.8;
      }

      .dragLine.hidden {
          stroke-width: 0;
      }
    </style>
  </head>
  <body>
    <div id="svg-wrap">
      <script src="https://d3js.org/d3.v4.min.js"></script> 
      <script>



	"use strict";
	//node ids are in order in which nodes come in existence
	var nodes = [{ id: 1 }, { id: 2 }, { id: 3 }];

	var links = [
            { source: 0, target: 1, weight: 1 },
            { source: 0, target: 2, weight: 2 },
            { source: 1, target: 2, weight: 10}
	];

	var source = 1;

	var lastNodeId = nodes.length;
	var rad = 10;
	var h = 400;
	var w = 600;

	var svg = d3
            .select("#svg-wrap")
            .append("svg")
            .attr("width", w)
            .attr("height", h);

	var dragLine = svg
            .append("path")
            .attr("class", "dragLine hidden")
            .attr("d", "M0,0L0,0");

	var edges = svg.append("g").selectAll(".edge");

	var vertices = svg.append("g").selectAll(".vertex");

	var force = d3
            .forceSimulation()
            .force(
		"charge",
		d3
                    .forceManyBody()
                    .strength(-300)
                    .distanceMax(w / 2)
            )
            .force("link", d3.forceLink().distance(60))
            .force("x", d3.forceX(w / 2))
            .force("y", d3.forceY(h / 2))
            .on("tick", tick);

	force.nodes(nodes);
	force.force("link").links(links);

	var colors = d3.schemeCategory10;

	var mousedownNode = null;

	var clrBtn = d3.select("#clear-graph");
	clrBtn.on("click", clearGraph);

	var dist = {};
	var pred = {};

	function dijkstra() {
	    let Q = [];

            dist = {};
            pred = {};

            for (let node of nodes) {
		dist[node.id] = Infinity;
		pred[node.id] = null;
		Q.push(node.id);
            }

            dist[source] = 0;

	    while (Q.length > 0) {
		let u = Q[0];

		for (let v of Q) {
		    if (dist[v] < dist[u])
			u = v;
		}

		Q.splice(Q.indexOf(u), 1);

		for (let link of links) {
		    let a = link.source.id;
		    let b = link.target.id;
		    let w = link.weight;

		    if (a === u) {
			if (dist[u] + w < dist[b]) {
			    dist[b] = dist[u] + w;
			    pred[b] = u;
			}
		    }
		    // We need to check both directions.
		    if (b === u) {
			if (dist[u] + w < dist[a]) {
			    dist[a] = dist[u] + w;
			    pred[a] = u;
			}
		    }
		}
	    }
	}
	function bellmanford() {
            dist = {};
            pred = {};

            for (let node of nodes) {
		dist[node.id] = Infinity;
		pred[node.id] = null;
            }

            dist[source] = 0;

            for (let node of nodes) {
		for (let link of links) {
                    let u = link.source.id;
                    let v = link.target.id;
                    let w = link.weight;

		    // We use undirected edges.
                    if (dist[u] + w < dist[v]) {
			dist[v] = dist[u] + w;
			pred[v] = u;
                    }
		    // We need to check both directions.
                    if (dist[v] + w < dist[u]) {
			dist[u] = dist[v] + w;
			pred[u] = v;
                    }
		}
	    }
	}

	/*
    _ ____                     _
 __| |__ /  __ _ _ _ __ _ _ __| |_
/ _` ||_ \ / _` | '_/ _` | '_ \ ' \
\__,_|___/ \__, |_| \__,_| .__/_||_|
           |___/         |_|
	   
	  */
	//empties the graph
	function clearGraph() {
            nodes.splice(0);
            links.splice(0);
            lastNodeId = 0;
            restart();
	}

	//update the simulation
	function tick() {
            edges
		.attr("x1", function(d) {
                    return d.source.x;
		})
		.attr("y1", function(d) {
                    return d.source.y;
		})
		.attr("x2", function(d) {
                    return d.target.x;
		})
		.attr("y2", function(d) {
                    return d.target.y;
		});

            vertices
		.attr("cx", function(d) {
                    return d.x;
		})
		.attr("cy", function(d) {
                    return d.y;
		});
	}

	function addNode() {
            var e = d3.event;
            if (e.button == 0) {
		var coords = d3.mouse(e.currentTarget);
		var newNode = { x: coords[0], y: coords[1], id: ++lastNodeId };
		nodes.push(newNode);
		restart();
            }
	}

	function removeNode(d, i) {
            //to make ctrl-drag works for mac/osx users
            if (d3.event.ctrlKey) return;
            nodes.splice(nodes.indexOf(d), 1);
            var linksToRemove = links.filter(function(l) {
		return l.source === d || l.target === d;
            });
            linksToRemove.map(function(l) {
		links.splice(links.indexOf(l), 1);
            });
            d3.event.preventDefault();
            restart();
	}

	function removeEdge(d, i) {
            links.splice(links.indexOf(d), 1);
            d3.event.preventDefault();
            restart();
	}

	function beginDragLine(d) {
            //to prevent call of addNode through svg
            d3.event.stopPropagation();
            //to prevent dragging of svg in firefox
            d3.event.preventDefault();
            if (d3.event.ctrlKey || d3.event.button != 0) return;
            mousedownNode = d;
            dragLine
		.classed("hidden", false)
		.attr(
                    "d",
                    "M" +
			mousedownNode.x +
			"," +
			mousedownNode.y +
			"L" +
			mousedownNode.x +
			"," +
			mousedownNode.y
		);
	}

	function updateDragLine() {
            var coords = d3.mouse(d3.event.currentTarget);
            if (!mousedownNode) return;
            dragLine.attr(
		"d",
		"M" +
                    mousedownNode.x +
                    "," +
                    mousedownNode.y +
                    "L" +
                    coords[0] +
                    "," +
                    coords[1]
            );
	}

	function hideDragLine() {
            dragLine.classed("hidden", true);
            mousedownNode = null;
            restart();
	}

	//no need to call hideDragLine() and restart() in endDragLine
	//mouseup on vertices propagates to svg which calls hideDragLine
	function endDragLine(d) {
            if (!mousedownNode || mousedownNode === d) return;
            //return if link already exists
            for (let i = 0; i < links.length; i++) {
		var l = links[i];
		if (
                    (l.source === mousedownNode && l.target === d) ||
			(l.source === d && l.target === mousedownNode)
		) {
                    return;
		}
            }
            var newLink = { source: mousedownNode, target: d, weight: 1};
            links.push(newLink);
	}

	//one response per ctrl keydown
	var lastKeyDown = -1;

	function keydown() {
            d3.event.preventDefault();
            if (lastKeyDown !== -1) return;
            lastKeyDown = d3.event.key;

            if (lastKeyDown === "Control") {
		vertices.call(
                    d3
			.drag()
			.on("start", function dragstarted(d) {
                            if (!d3.event.active) force.alphaTarget(1).restart();
                            d.fx = d.x;
                            d.fy = d.y;
			})
			.on("drag", function(d) {
                            d.fx = d3.event.x;
                            d.fy = d3.event.y;
			})
			.on("end", function(d) {
                            if (!d3.event.active) force.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
			})
		);
            }
	}

	function keyup() {
            lastKeyDown = -1;
            if (d3.event.key === "Control") {
		vertices.on("mousedown.drag", null);
            }
	}

	function setWeight(d, i) {
	    d3.event.stopPropagation();
	    let source = d.source;
	    let target = d.target;
	    removeEdge(d, i);
            var newLink = { source, target, weight: parseInt(prompt('weight'))};
            links.push(newLink);
	}
	//updates graph by updating links, nodes and binding them with DOM
	//interface is defined through several events
	function restart() {
            edges = edges.data(links, function(d) {
		return "v" + d.source.id + "-v" + d.target.id;
            });
            edges.exit().remove();

            var ed = edges
		.enter()
		.append("line")
		.attr("class", "edge")
		.on("mousedown", setWeight)
		.on("contextmenu", removeEdge);

            ed.append("title").text(function(d) {
		return "v" + d.source.id + "-v" + d.target.id + " (" + d.weight + ")";
            });

            edges = ed.merge(edges);

            //vertices are known by id
            vertices = vertices.data(nodes, function(d) {
		return d.id;
            });
            vertices.exit().remove();

            var ve = vertices
		.enter()
		.append("circle")
		.attr("r", rad)
		.attr("class", "vertex")
		.style("fill", function(d, i) {
                    return colors[d.id % 10];
		})
		.on("mousedown", beginDragLine)
		.on("mouseup", endDragLine)
		.on("dblclick", function(d, i) {
		    source = d.id; 
		})
		.on("contextmenu", removeNode);

            ve.append("title").text(function(d) {
		return "v" + d.id;
            });

            vertices = ve.merge(vertices);

            force.nodes(nodes);
            force.force("link").links(links);
            force.alpha(0.8).restart();
	}

	//further interface
	svg
    .on("mousedown", addNode)
    .on("mousemove", updateDragLine)
    .on("mouseup", hideDragLine)
    .on("contextmenu", function() {
        d3.event.preventDefault();
    })
    .on("mouseleave", hideDragLine);

	d3.select(window)
    .on("keydown", keydown)
    .on("keyup", keyup);

	restart();
      </script>
    </div>
  </body>
</html>
